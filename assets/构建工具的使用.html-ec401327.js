import{_ as e,o as l,c as a,a as i}from"./app-1abbb6ea.js";const o="/Lin-Note-v2/assets/d77fc560-a658-11eb-85f6-6fac77c0c9b3-87e45067.png",c={},p=i('<h1 id="构建工具的使用" tabindex="-1"><a class="header-anchor" href="#构建工具的使用" aria-hidden="true">#</a> 构建工具的使用</h1><h2 id="_1-描述下你对-webpack-的理解-解决了什么问题" tabindex="-1"><a class="header-anchor" href="#_1-描述下你对-webpack-的理解-解决了什么问题" aria-hidden="true">#</a> 1. 描述下你对 webpack 的理解? 解决了什么问题?</h2><p><strong>理解</strong>：webpack 是一款静态模块打包工具</p><p><strong>解决了什么问题</strong></p><ul><li>解决浏览器兼容性问题 (编译代码能力) - 如 ES5 转 ES6</li><li>解决浏览器频繁请求文件的问题 (模块整合能力) - 如 将很多 JS 文件整合成一个 Bundle.js</li><li>使项目维护性增强, 支持不同种类的前端模块类型, 统一的模块化方案, 所有资源文件的加载都可以通过代码控制 - 如 .css、.scss 都可以整合成一个 .css, 而 .ts、.js 可以整合成一个 Bundle.js</li></ul><h2 id="_2-说一说-webpack-的构建流程" tabindex="-1"><a class="header-anchor" href="#_2-说一说-webpack-的构建流程" aria-hidden="true">#</a> 2. 说一说 webpack 的构建流程</h2><p>配置文件默认下为<code>webpack.config.js</code>，也或者通过命令的形式指定配置文件，主要作用是用于激活<code>webpack</code>的加载项和插件</p><p><img src="'+o+`" alt="img"></p><h2 id="_3-说说-webpack-中常见的-loader-解决了什么问题" tabindex="-1"><a class="header-anchor" href="#_3-说说-webpack-中常见的-loader-解决了什么问题" aria-hidden="true">#</a> 3. 说说 webpack 中常见的 Loader? 解决了什么问题?</h2><p><strong>常见的 Loader</strong></p><ul><li><p>html-minify-loader</p></li><li><p>style-loader | css-loader | less-loader | sass-loader</p></li><li><p>postcss-loader</p></li><li><p>file-loader | url-loader</p></li><li><p>babel-loader</p></li></ul><p><strong>解决的问题</strong></p><p><code>webpack</code> 只支持对 js 和 json 文件打包</p><p>像 <code>css</code>、<code>sass</code>、<code>png</code> 等这些类型的文件的时候, <code>webpack</code> 则无能为力, 这时候就需要配置对应的 <code>loader</code> 进行文件内容的解析</p><h2 id="_4-说说-webpack-中常见的-plugin-解决了什么问题" tabindex="-1"><a class="header-anchor" href="#_4-说说-webpack-中常见的-plugin-解决了什么问题" aria-hidden="true">#</a> 4. 说说 webpack 中常见的 Plugin? 解决了什么问题?</h2><p><strong>常见的 Plugin</strong></p><ul><li>HtmlWebpackPlugin</li><li>mini-css-extract-plugin</li><li>clean-webpack-plugin</li><li>DefinePlugin</li><li>copy-webpack-plugin</li></ul><p><strong>解决的问题</strong></p><p>目的在于解决<code>loader</code> 无法实现的其他事</p><h2 id="_5-说说-loader-和-plugin-的区别-编写-loader-plugin-的思路" tabindex="-1"><a class="header-anchor" href="#_5-说说-loader-和-plugin-的区别-编写-loader-plugin-的思路" aria-hidden="true">#</a> 5. 说说 Loader 和 Plugin 的区别? 编写 Loader, Plugin 的思路?</h2><p><strong>Loader 和 Plugin 的区别</strong></p><p>可有看到, 两者在运行时机上的区别:</p><ul><li>loader 运行在打包文件之前</li><li>plugins 在整个编译周期都起作用</li></ul><p><strong>编写 Loader 的思路</strong></p><p>保持功能单一, 避免做多种功能</p><p>如<code>less</code>文件转换成 <code>css</code>文件也不是一步到位，而是 <code>less-loader</code>、<code>css-loader</code>、<code>style-loader</code>几个 <code>loader</code>的链式调用才能完成转换</p><p><strong>编写 Plugin 的思路</strong></p><ul><li>插件必须是一个函数或者一个包含 <code>apply</code> 方法的对象, 这样才能访问 <code>compiler</code> 实例</li><li>传给每个插件的 <code>compiler</code> 和 <code>compilation</code> 对象都是同一个引用, 因此不建议修改</li><li>异步的事情需要在处理完成任务时调用回调函数通知 <code>webpack</code> 进入下一个流程, 不然会卡住</li></ul><h2 id="_6-热更新是什么-webpack-的热更新是如何做到的-原理是什么" tabindex="-1"><a class="header-anchor" href="#_6-热更新是什么-webpack-的热更新是如何做到的-原理是什么" aria-hidden="true">#</a> 6. 热更新是什么? webpack 的热更新是如何做到的? 原理是什么?</h2><p><strong>热更新</strong></p><p>可以理解为模块热替换, 指在应用程序运行过程中, 替换、添加、删除模块, 而无需重新刷新整个应用</p><p><strong>webpack 热更新如何实现</strong></p><p>直接进行简单配置即可</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>const webpack = require(&#39;webpack&#39;)
module.exports = <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 开启 HMR 特性</span>
    hot<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token comment">// hotOnly: true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>webpack 热更新原理</strong></p><ul><li>大概流程是我们用 <code>webpack-dev-server</code> 启动一个服务之后</li><li>浏览器和服务端是通过 <code>websocket</code> 进行长连接，<code>webpack</code> 内部实现的 <code>watch</code> 就会监听文件修改，只要有修改就 <code>webpack</code> 会重新打包编译到内存中</li><li>然后 <code>webpack-dev-server</code> 依赖中间件 <code>webpack-dev-middleware</code> 和 <code>webpack</code> 之间进行交互，每次热更新都会请求一个携带 <code>hash</code> 值的 <code>json</code> 文件和一个 <code>js</code></li><li><code>websocker</code> 传递的也是 <code>hash</code> 值，内部机制通过 <code>hash</code> 值检查进行热更新</li></ul><h2 id="_7-说说-webpack-proxy-工作原理-为什么能解决跨域问题" tabindex="-1"><a class="header-anchor" href="#_7-说说-webpack-proxy-工作原理-为什么能解决跨域问题" aria-hidden="true">#</a> 7. 说说 webpack proxy 工作原理? 为什么能解决跨域问题?</h2><p><strong>webpack proxy 工作原理</strong></p><p><code>proxy</code> 工作原理实质上是利用 <code>http-proxy-middleware</code> 这个<code>http</code>代理中间件，实现请求转发给其他服务器</p><p><strong>为什么能解决跨域问题</strong></p><ul><li><p>跨域是, 由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题 (不同端口的服务)</p></li><li><p>而 <code>webpack proxy</code> 将本地请求转发给代理服务器, 代理服务器再去请求目标服务器</p></li><li><p>目标服务器响应数据后, 将数据返回给代理服务器, 最终由代理服务器将数据响应给本地</p></li><li><p>本质上利用服务器之间请求数据不存在跨域行为, 跨域行为是浏览器安全策略限制</p></li></ul><h2 id="_8-说说如何借助-webpack-来优化前端性能" tabindex="-1"><a class="header-anchor" href="#_8-说说如何借助-webpack-来优化前端性能" aria-hidden="true">#</a> 8. 说说如何借助 webpack 来优化前端性能?</h2><p><strong>webpack 优化前端的手段</strong></p><ul><li>HTML、CSS、JS 代码压缩</li><li>文件、图片压缩</li><li>Tree Shaking (消除死代码)</li><li>代码分离</li><li>内联 chunk</li></ul><p><strong>webpack 如何优化</strong></p><p>可以通过文件体积大小入手, 其次还可以通过分包的形式, 减少 <code>http</code> 请求数等方式</p><p><strong>Tree Shaking</strong></p><p>清除实际上并没有在项目中使用的代码</p><h2 id="_9-如何提高-webpack-的构建速度" tabindex="-1"><a class="header-anchor" href="#_9-如何提高-webpack-的构建速度" aria-hidden="true">#</a> 9. 如何提高 webpack 的构建速度?</h2><p><strong>提高构建速度的手段</strong></p><ul><li>优化 loader 配置</li><li>合理使用 resolve.extensions</li><li>优化 resolve.modules</li><li>优化 resolve.alias</li><li>使用 DLLPlugin 插件</li><li>使用 cache-loader</li><li>terser 启动多线程</li><li>合理使用 sourceMap</li></ul><p><strong>webpack 构建速度如何提升</strong></p><p>主要可以从优化搜索时间、缩小文件搜索范围、减少不必要的编译等方面入手</p><h2 id="_10-前端打包工具有哪些" tabindex="-1"><a class="header-anchor" href="#_10-前端打包工具有哪些" aria-hidden="true">#</a> 10. 前端打包工具有哪些?</h2><p><strong>打包构建工具</strong></p><ul><li>Rollup</li><li>Parcel</li><li>Snowpack</li><li>Vite</li><li>Webpack</li></ul><h2 id="_11-rollup-vs-webpack" tabindex="-1"><a class="header-anchor" href="#_11-rollup-vs-webpack" aria-hidden="true">#</a> 11. Rollup vs Webpack</h2><p>Rollup 对原生 ES 语法支持, 对 tree shaking 这样的使用场景非常的友好</p><p>Rollup 核心概念: input、output、format、plugins</p><p>plugins的使用方式: 顺序引用, 顺序执行</p><h2 id="_12-rollup-常用插件" tabindex="-1"><a class="header-anchor" href="#_12-rollup-常用插件" aria-hidden="true">#</a> 12. Rollup 常用插件</h2><p>最常用</p><ul><li>resolve 解析一些 node_modules</li><li>commonjs 转换为 commonjs 语法</li></ul><p>类型解析</p><ul><li>json | babel | typescript | image | html | wasm</li></ul><p>功能扩展</p><ul><li>replace 变量替换</li><li>eslint 代码规范</li><li>alias 路径替换</li><li>strip 去除 console、空格这些</li><li>terser (uglify) 压缩代码</li></ul><h2 id="_13-rollup-中用-babel-与-typescript-打包有什么区别" tabindex="-1"><a class="header-anchor" href="#_13-rollup-中用-babel-与-typescript-打包有什么区别" aria-hidden="true">#</a> 13. Rollup 中用 babel 与 typescript 打包有什么区别?</h2><p>babel</p><ul><li>缺点: 打包的时候是不会进行类型检查</li><li>优点: 不进行类型检查, 所以速度比 typescript 更快</li></ul><blockquote><p>使用 babel 或 typescript 需要根据场景来, 需要类型检查就用 typescript</p></blockquote>`,71),s=[p];function d(r,n){return l(),a("div",null,s)}const u=e(c,[["render",d],["__file","构建工具的使用.html.vue"]]);export{u as default};
